" Early Setup {{{
if has('vim_starting') && &encoding !=# 'utf-8'
   set encoding=utf-8
endif
scriptencoding utf-8

augroup vimrc
  autocmd!
augroup END

let g:vimconf = split(&runtimepath, ',')[0]
if !empty($XDG_DATA_HOME)
  let g:vimdata = $XDG_DATA_HOME.'/vim'
elseif has('win32') || has('win64')
  let g:vimdata = !empty($LOCALAPPDATA) ? $LOCALAPPDATA.'/vim' : g:vimconf
else
  let g:vimdata = expand('~/.local/share/vim')
endif

runtime local.vim

if has('gui_running')
  set guioptions-=m guioptions+=M
endif
" }}}

" General {{{
  filetype plugin indent on
  set autoread
  set hidden
  set path+=**
  set fileformats=unix,dos,mac
  set shortmess+=a
  set viminfo=

  set backupskip+=*/tmp/*,/dev/shm/*
  let &backupdir = g:vimdata.'/backup'
  if !isdirectory(&backupdir)
    call mkdir(&backupdir, 'p')
  endif

  let &directory = g:vimdata.'/swap//'
  if !isdirectory(&directory)
    call mkdir(&directory, 'p')
  endif

  if exists('+undofile')
    autocmd vimrc BufWritePre /tmp/*,*/tmp/*,/dev/shm/* setlocal noundofile

    let &undodir = g:vimdata.'/undo'
    if !isdirectory(&undodir)
      call mkdir(&undodir, 'p')
    endif
    set undofile
  endif

  autocmd vimrc BufRead /tmp/*,*/tmp/*,/dev/shm/* setlocal noswapfile
  autocmd vimrc BufWritePost $MYVIMRC nested source $MYVIMRC
" }}}

" Interface {{{
  set ttyfast
  set lazyredraw
  set scrolloff=5
  set sidescroll=1
  set sidescrolloff=10
  set list
  set listchars=tab:▸\ ,nbsp:␣,trail:•,eol:¬,precedes:…,extends:…
  set number
  set relativenumber
  set cursorline
  set cursorcolumn
  set colorcolumn=+1
  set showcmd
  set noshowmode
  set laststatus=2
  set statusline=
  set statusline+=%{&paste?'[PASTE]\ ':''}%r%f%(\ %M%)%=
  set statusline+=%{&spell?&spelllang.'\ ':''}
  set statusline+=%{!empty(&ft)?&ft:'no\ ft'}
  set statusline+=\ \|\ %{strlen(&fenc)?&fenc:&enc}
  set statusline+=\ \|\ %{&ff}
  set statusline+=\ :\ %3p%%\ :%3l:%-3v
  set display+=lastline

  set splitbelow splitright

  set nowrap
  set linebreak
  set breakindent
  let &showbreak='↪ '

  set nofoldenable
  set foldmethod=syntax
  set foldcolumn=1
  set foldminlines=5
  set foldopen+=insert
  set fillchars=diff:⎼,fold:⎼

  set wrapscan
  set hlsearch
  set incsearch
  set ignorecase
  set smartcase

  set wildmenu
  set wildignorecase
  set wildmode=longest:full,full
  set wildignore+=*.swp,*.bak,.DS_Store,._*,*~
  set wildignore+=*.pyc,*.rlib,*.class,*.o,*.obj,*.a,*.lib,*.so,*.dll,*.pdb
  set wildignore+=*/.git/**/*,*/.hg/**/*,*/.svn/**/*
  set wildignore+=tags,cscope.*

  if has('gui_running')
    if has('gui_win32')
      if exists('&renderoptions')
        set renderoptions=type:directx,geom:1,renmode:5,taamode:1
      endif
      set guifont^=Source_Code_Pro:h10,Noto_Mono:h10,DejaVu_Sans_Mono:h10,Courier_New:h10
    else
      set guifont^=Source\ Code\ Pro\ 10,Noto\ Mono\ 10,DejaVu\ Sans\ Mono\ 10
    endif
    set guioptions-=r guioptions-=R guioptions-=l guioptions-=L guioptions-=T
  endif

  try
    let g:breeze_use_palette = !$NOPALETTE
    colorscheme breeze
  catch /^Vim\%((\a\+)\)\=:E185/
    colorscheme slate
  endtry

  autocmd vimrc InsertEnter * set norelativenumber
  autocmd vimrc InsertLeave * set relativenumber
  autocmd vimrc WinEnter * if exists('w:cursor') |
        \ let [&cursorline, &cursorcolumn] = w:cursor |
        \ elseif &buftype ==# 'terminal' |
        \ setlocal nocursorcolumn nocursorline |
        \ endif
  autocmd vimrc WinLeave * let w:cursor = [&cursorline, &cursorcolumn] |
        \ setlocal nocursorline nocursorcolumn
  autocmd vimrc FileType qf,netrw setlocal cursorline nocursorcolumn |
        \ nnoremap <silent> <buffer> q <C-W>c
  autocmd vimrc FileType help wincmd L
" }}}

" Editing {{{
  set smarttab
  set expandtab
  set shiftwidth=2
  set softtabstop=-1
  set tabstop=4

  set confirm
  set nostartofline
  set matchpairs+=<:>,[:]
  set formatoptions+=qjl1
  set backspace=indent,eol,start
  set virtualedit=block
  set autoindent
  set copyindent
  set preserveindent
  set complete+=kspell
  set completeopt+=menuone
  set spelllang=en_us
  set dictionary^=spell
  if filereadable('/usr/share/dict/words')
    set dictionary+=/usr/share/dict/words
  endif
  set diffopt+=iwhite

  if exists('&inccommand')
    set inccommand=nosplit
  endif

  set ttimeout
  set ttimeoutlen=100
" }}}

" Commands {{{
  if executable('xclip')
    command! -range Copy <line1>,<line2>write !xclip -f -sel clip
    command! Paste read !xclip -o -sel clip
  endif

  command! -nargs=+ EditConfig call <SID>EditConfig(<f-args>)
  function! s:EditConfig(what, ...) abort
    let l:name = get(a:000, 0, &filetype)
    if empty(l:name)
      return
    endif
    let l:stem = a:what.'/'.l:name.'.vim'
    if filewritable(g:vimconf.'/after/'.l:stem) ||
          \ (!filewritable(g:vimconf.'/'.l:stem) && findfile(l:stem, &runtimepath) !=# '')
      execute ':vsplit '.g:vimconf.'/after/'.l:stem
    else
      execute ':vsplit '.g:vimconf.'/'.l:stem
    endif
  endfunction

  autocmd vimrc QuickFixCmdPost [^l]* nested botright cwindow|redraw!
  autocmd vimrc QuickFixCmdPost    l* nested lwindow|redraw!

  if executable('rg')
    set grepprg=rg\ --vimgrep\ --no-heading\ -S
    set grepformat^=%f:%l:%c:%m
  elseif executable('ag')
    set grepprg=ag\ --vimgrep
    set grepformat^=%f:%l:%c:%m
  else
    set grepprg=grep\ -srnH
  endif
" }}}

" Mappings {{{
  " Navigation {{{
    nnoremap <C-Space> :ls<CR>:b<SPACE>
    nnoremap gb <C-^>

    nnoremap <expr> j v:count == 0 ? 'gj' : 'j'
    nnoremap <expr> k v:count == 0 ? 'gk' : 'k'
  " }}}
  " Unimpaired mappings {{{
    for s:cmd in [['a', ''], ['b', 'b'], ['t', 't'], ['q', 'c'], ['l', 'l']]
      execute 'nnoremap <silent> <expr> ['.s:cmd[0]." ':<C-U>'.v:count1.'".s:cmd[1]."prev<CR>'"
      execute 'nnoremap <silent> <expr> ]'.s:cmd[0]." ':<C-U>'.v:count1.'".s:cmd[1]."next<CR>'"
      execute 'nnoremap <silent> ['.toupper(s:cmd[0]).' :<C-U>'.s:cmd[1].'first<CR>'
      execute 'nnoremap <silent> ]'.toupper(s:cmd[0]).' :<C-U>'.s:cmd[1].'last<CR>'
    endfor
    for s:opt in [['s', 'spell'], ['et', 'expandtab'], ['w', 'wrap'], ['r', 'relativenumber'], ['l', 'list']]
      execute 'nnoremap <silent> [o'.s:opt[0].' :setlocal '.s:opt[1].'<CR>'
      execute 'nnoremap <silent> ]o'.s:opt[0].' :setlocal no'.s:opt[1].'<CR>'
      execute 'nnoremap <silent> co'.s:opt[0].' :setlocal '.s:opt[1].'!<CR>'
    endfor
    nnoremap <silent> [ts :setlocal tabstop=4<CR>
    nnoremap <silent> ]ts :setlocal tabstop=8<CR>
    nnoremap <silent> [od :diffthis<CR>
    nnoremap <silent> ]od :diffoff<CR>
    nnoremap <silent> <expr> cod (&diff?':diffoff':':diffthis').'<CR>'
    nnoremap <silent> [oy :setlocal syntax=ON<CR>
    nnoremap <silent> ]oy :setlocal syntax=OFF<CR>
    nnoremap <silent> <expr> coy ':setlocal syntax='.(&l:syntax==#'OFF'?'ON':'OFF').'<CR>'
    nnoremap <silent> [<Space> :<C-U>put! =repeat(nr2char(10), v:count1)<CR>']+1
    nnoremap <silent> ]<Space> :<C-U>put =repeat(nr2char(10), v:count1)<CR>'[-1
  " }}}
  nnoremap <expr> g. '`['.strpart(getregtype(), 0, 1).'`]'
  nnoremap <silent> <expr> gs ':silent! grep! -w -F '.shellescape(expand('<cword>'), 1).'<CR>'
  nnoremap <silent> <C-L> :nohlsearch<Bar>diffupdate<CR><C-L>
  nnoremap <silent> <Leader>d :bd<CR>
  nnoremap <silent> <Leader>i1 :setlocal expandtab shiftwidth=2<CR>
  nnoremap <silent> <Leader>i2 :setlocal expandtab shiftwidth=4<CR>
  nnoremap <silent> <Leader>i3 :setlocal noexpandtab shiftwidth=4 tabstop=4<CR>
  nnoremap <silent> <Leader>i4 :setlocal noexpandtab shiftwidth=8 tabstop=8<CR>
  nnoremap <silent> <Leader>sv :source $MYVIMRC<CR>
  nnoremap <silent> <Leader>ev :vsplit $MYVIMRC<CR>
  nnoremap <silent> <expr> <Leader>el ':vsplit '.g:vimconf.'/local.vim<CR>'
  nnoremap <silent> <expr> <Leader>ep ':vsplit '.g:vimconf.'/plugins.vim<CR>'
  nnoremap <silent> <Leader>ec :EditConfig colors <C-R>=g:colors_name<CR><CR>
  nnoremap <silent> <Leader>ef :EditConfig ftplugin<CR>
  nnoremap <silent> <Leader>es :EditConfig syntax<CR>

  inoremap <C-W> <C-G>u<C-W>
  inoremap <C-U> <C-G>u<C-U>

  xnoremap ae gg0oG$
  onoremap ae :<C-U>keepjumps normal! ggVG<CR>

  cabbrev <expr> %% fnameescape(expand('%'))
  cabbrev <expr> :: fnameescape(expand('%:h'))
" }}}

" File Type {{{
  let g:rust_fold = 1

  autocmd vimrc FileType vim setlocal keywordprg=:help
  autocmd vimrc FileType man setlocal nolist noexpandtab sw=8 ts=8
  autocmd vimrc FileType gitcommit,text,markdown,pandoc,html,c,cpp,rust setlocal spell
  if executable('hindent')
    autocmd vimrc FileType haskell setlocal equalprg=hindent
  endif
" }}}

" Projects {{{
  set tagcase=smart
  set tags=./tags;,tags
  set sessionoptions-=curdir
  set sessionoptions+=winpos,sesdir

  let s:gitroot = get(systemlist('git rev-parse --show-toplevel'), 0, '')
  if v:shell_error == 0 && !empty(s:gitroot)
    let &path .= ','.s:gitroot.'/**'
    let &tags .= ','.s:gitroot.'/.git/tags'
  endif

  autocmd vimrc FileType * let &l:tags = &tags.','.expand(g:vimdata.'/tags/').&ft
" }}}

" Plugins {{{
  let g:netrw_home = g:vimdata
  if !has('nvim')
    packadd! matchit
  endif
  runtime plugins.vim
" }}}

if exists('*local#finish')
  call local#finish()
endif
" vim:set sw=2 ts=2 et fdm=marker fdl=0:
